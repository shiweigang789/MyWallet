package io.horizontalsystems.bitcoincore.network.messages

import io.horizontalsystems.bitcoincore.core.IHasher
import io.horizontalsystems.bitcoincore.extensions.toReversedHex
import io.horizontalsystems.bitcoincore.io.BitcoinInput
import io.horizontalsystems.bitcoincore.io.BitcoinOutput
import io.horizontalsystems.bitcoincore.storage.BlockHeader
import java.io.ByteArrayInputStream

class HeadersMessage(val headers: Array<BlockHeader>) : IMessage {
    override fun toString(): String {
        return "HeadersMessage(${headers.size}:[${headers.joinToString { it.hash.toReversedHex() }}])"
    }
}

class HeadersMessageParser(private val hasher: IHasher) : IMessageParser {
    override val command: String = "headers"

    override fun parseMessage(payload: ByteArray): IMessage {
        return BitcoinInput(ByteArrayInputStream(payload)).use { input ->
            val count = input.readVarInt().toInt()

            val headers = Array(count) {
                val version = input.readInt()
                val prevHash = input.readBytes(32)
                val merkleHash = input.readBytes(32)
                val timestamp = input.readUnsignedInt()
                val bits = input.readUnsignedInt()
                val nonce = input.readUnsignedInt()
                input.readVarInt() // tx count always zero

                val headerPayload = BitcoinOutput().also {
                    it.writeInt(version)
                    it.write(prevHash)
                    it.write(merkleHash)
                    it.writeUnsignedInt(timestamp)
                    it.writeUnsignedInt(bits)
                    it.writeUnsignedInt(nonce)
                }

                BlockHeader(version, prevHash, merkleHash, timestamp, bits, nonce, hasher.hash(headerPayload.toByteArray()))
            }

            HeadersMessage(headers)
        }
    }
}

class HeadersMessageSerializer : IMessageSerializer {
    override val command: String = "headers"

    override fun serialize(message: IMessage): ByteArray? {
        if (message !is HeadersMessage) {
            return null
        }

        val output = BitcoinOutput().also {
            it.writeInt(message.headers.size)
        }

        message.headers.forEach {
            output.writeInt(it.version)
            output.write(it.previousBlockHeaderHash)
            output.write(it.merkleRoot)
            output.writeUnsignedInt(it.timestamp)
            output.writeUnsignedInt(it.bits)
            output.writeUnsignedInt(it.nonce)
        }

        return output.toByteArray()
    }
}
